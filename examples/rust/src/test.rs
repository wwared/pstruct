// AUTOGENERATED - MAY BE OVERWRITTEN

#[allow(unused_assignments, unused_variables)]
pub mod pstruct {
    use pstruct_rs::*;
    use std::ffi::CString;
    #[derive(Debug)]
    pub struct Test {
        pub a: u8,
        pub b: u16,
        pub c: u32,
        pub d: u64,
        pub e: i8,
        pub f: i16,
        pub g: i32,
        pub h: i64,
        pub i: u8,
        pub j: f32,
        pub k: f64,
        pub l: String,
        pub m: CString,
        pub n: Wow,
        pub o: [u8; 16usize],
        pub u: [String; 3usize],
        pub v: [Wow; 2usize],
        pub w: Vec<u8>,
        pub x: Vec<Wow>,
        pub y: Vec<u8>,
        pub z: CString,
    }
    impl Default for Test {
        fn default() -> Self {
            Self {
                a: Default::default(),
                b: Default::default(),
                c: Default::default(),
                d: Default::default(),
                e: Default::default(),
                f: Default::default(),
                g: Default::default(),
                h: Default::default(),
                i: Default::default(),
                j: Default::default(),
                k: Default::default(),
                l: Default::default(),
                m: Default::default(),
                n: Default::default(),
                o: [
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                ],
                u: [Default::default(), Default::default(), Default::default()],
                v: [Default::default(), Default::default()],
                w: vec![],
                x: vec![],
                y: vec![],
                z: Default::default(),
            }
        }
    }
    impl Pstruct for Test {
        fn encode(&self) -> Result<Vec<u8>> {
            let mut res = vec![0; self.size()];
            self.encode_buf(&mut res)?;
            Ok(res)
        }
        fn encode_buf(&self, buf: &mut [u8]) -> Result<()> {
            assert!(buf.len() >= self.size(), "todo improve errors");
            let mut buf = buf;
            self.a.encode_le(&mut buf[..1])?;
            buf = &mut buf[1..];
            self.b.encode_le(&mut buf[..2])?;
            buf = &mut buf[2..];
            self.c.encode_le(&mut buf[..4])?;
            buf = &mut buf[4..];
            self.d.encode_le(&mut buf[..8])?;
            buf = &mut buf[8..];
            self.e.encode_le(&mut buf[..1])?;
            buf = &mut buf[1..];
            self.f.encode_le(&mut buf[..2])?;
            buf = &mut buf[2..];
            self.g.encode_le(&mut buf[..4])?;
            buf = &mut buf[4..];
            self.h.encode_le(&mut buf[..8])?;
            buf = &mut buf[8..];
            self.i.encode_le(&mut buf[..1])?;
            buf = &mut buf[1..];
            self.j.encode_le(&mut buf[..4])?;
            buf = &mut buf[4..];
            self.k.encode_le(&mut buf[..8])?;
            buf = &mut buf[8..];
            (self.l.len() as u16).encode_le(&mut buf[..2])?;
            buf = &mut buf[2..];
            self.l
                .as_bytes()
                .to_vec()
                .encode_le(&mut buf[..self.l.len()])?;
            buf = &mut buf[self.l.len()..];
            assert!(self.m.as_bytes().len() < 40usize, "cstring too large");
            self.m
                .as_bytes()
                .to_vec()
                .encode_le(&mut buf[..self.m.as_bytes().len()])?;
            for idx in self.m.as_bytes().len()..40usize {
                buf[idx] = 0;
            }
            buf = &mut buf[40usize..];
            self.n.encode_buf(&mut buf[..self.n.size()])?;
            buf = &mut buf[self.n.size()..];
            for idx in 0..self.o.len() {
                self.o[idx].encode_le(&mut buf[..1])?;
                buf = &mut buf[1..];
            }
            for idx in 0..self.u.len() {
                (self.u[idx].len() as u16).encode_le(&mut buf[..2])?;
                buf = &mut buf[2..];
                self.u[idx]
                    .as_bytes()
                    .to_vec()
                    .encode_le(&mut buf[..self.u[idx].len()])?;
                buf = &mut buf[self.u[idx].len()..];
            }
            for idx in 0..self.v.len() {
                self.v[idx].encode_buf(&mut buf[..self.v[idx].size()])?;
                buf = &mut buf[self.v[idx].size()..];
            }
            assert!(self.w.len() == self.g as usize, "todo improve errors");
            for idx in 0..self.w.len() {
                self.w[idx].encode_le(&mut buf[..1])?;
                buf = &mut buf[1..];
            }
            assert!(self.x.len() == self.c as usize, "todo improve errors");
            for idx in 0..self.x.len() {
                self.x[idx].encode_buf(&mut buf[..self.x[idx].size()])?;
                buf = &mut buf[self.x[idx].size()..];
            }
            (self.y.len() as u8).encode_le(&mut buf[..1])?;
            buf = &mut buf[1..];
            for idx in 0..self.y.len() {
                self.y[idx].encode_le(&mut buf[..1])?;
                buf = &mut buf[1..];
            }
            assert!(self.z.as_bytes().len() < 255, "cstring too large");
            buf[0] = (self.z.as_bytes().len() + 1) as u8;
            buf = &mut buf[1..];
            self.z
                .as_bytes()
                .to_vec()
                .encode_le(&mut buf[..self.z.as_bytes().len()])?;
            buf[self.z.as_bytes().len()] = 0;
            buf = &mut buf[(self.z.as_bytes().len() + 1)..];
            Ok(())
        }
        fn decode_new(data: &[u8]) -> Result<Self> {
            let mut res = Self::default();
            res.decode(data)?;
            Ok(res)
        }
        fn decode(&mut self, data: &[u8]) -> Result<()> {
            assert!(data.len() >= self.size(), "todo improve errors");
            let mut data = data;
            let size = 1;
            self.a.decode_le(&data[..size])?;
            data = &data[size..];
            let size = 2;
            self.b.decode_le(&data[..size])?;
            data = &data[size..];
            let size = 4;
            self.c.decode_le(&data[..size])?;
            data = &data[size..];
            let size = 8;
            self.d.decode_le(&data[..size])?;
            data = &data[size..];
            let size = 1;
            self.e.decode_le(&data[..size])?;
            data = &data[size..];
            let size = 2;
            self.f.decode_le(&data[..size])?;
            data = &data[size..];
            let size = 4;
            self.g.decode_le(&data[..size])?;
            data = &data[size..];
            let size = 8;
            self.h.decode_le(&data[..size])?;
            data = &data[size..];
            let size = 1;
            self.i.decode_le(&data[..size])?;
            data = &data[size..];
            let size = 4;
            self.j.decode_le(&data[..size])?;
            data = &data[size..];
            let size = 8;
            self.k.decode_le(&data[..size])?;
            data = &data[size..];
            let mut tmp_len: u16 = 0;
            tmp_len.decode_le(&data[..2])?;
            data = &data[2..];
            let mut tmp_buf: Vec<u8> = vec![0; tmp_len as usize];
            tmp_buf.decode_le(&data[..(tmp_len as usize)])?;
            self.l = String::from_utf8(tmp_buf).unwrap();
            data = &data[(tmp_len as usize)..];
            let mut tmp_buf: Vec<u8> = vec![0; 40usize];
            tmp_buf.decode_le(&data[..(40usize)])?;
            let tmp_buf = tmp_buf.splitn(2, |c| *c == b'\0').next().unwrap();
            self.m = CString::new(tmp_buf).unwrap();
            data = &data[40usize..];
            self.n.decode(data)?;
            data = &data[self.n.size()..];
            for idx in 0..(16usize as usize) {
                let size = 1;
                self.o[idx].decode_le(&data[..size])?;
                data = &data[size..];
            }
            for idx in 0..(3usize as usize) {
                let mut tmp_len: u16 = 0;
                tmp_len.decode_le(&data[..2])?;
                data = &data[2..];
                let mut tmp_buf: Vec<u8> = vec![0; tmp_len as usize];
                tmp_buf.decode_le(&data[..(tmp_len as usize)])?;
                self.u[idx] = String::from_utf8(tmp_buf).unwrap();
                data = &data[(tmp_len as usize)..];
            }
            for idx in 0..(2usize as usize) {
                self.v[idx].decode(data)?;
                data = &data[self.v[idx].size()..];
            }
            self.w = Vec::with_capacity(self.g as usize);
            for idx in 0..(self.g as usize) {
                self.w.push(Default::default());
            }
            for idx in 0..(self.g as usize) {
                let size = 1;
                self.w[idx].decode_le(&data[..size])?;
                data = &data[size..];
            }
            self.x = Vec::with_capacity(self.c as usize);
            for idx in 0..(self.c as usize) {
                self.x.push(Default::default());
            }
            for idx in 0..(self.c as usize) {
                self.x[idx].decode(data)?;
                data = &data[self.x[idx].size()..];
            }
            let mut tmp_len: u8 = 0;
            tmp_len.decode_le(&data[..1])?;
            data = &data[1..];
            self.y = Vec::with_capacity(tmp_len as usize);
            for idx in 0..(tmp_len as usize) {
                self.y.push(Default::default());
            }
            for idx in 0..(tmp_len as usize) {
                let size = 1;
                self.y[idx].decode_le(&data[..size])?;
                data = &data[size..];
            }
            let tmp_len: u8 = data[0];
            data = &data[1..];
            let mut tmp_buf: Vec<u8> = vec![0; tmp_len as usize];
            tmp_buf.decode_le(&data[..(tmp_len as usize)])?;
            let tmp_buf = tmp_buf.splitn(2, |c| *c == b'\0').next().unwrap();
            self.z = CString::new(tmp_buf).unwrap();
            data = &data[(tmp_len as usize)..];
            Ok(())
        }
        fn size(&self) -> usize {
            1 + 2
                + 4
                + 8
                + 1
                + 2
                + 4
                + 8
                + 1
                + 4
                + 8
                + self.l.len()
                + 2
                + 40usize
                + self.n.size()
                + (16usize * (1))
                + (self.u.iter().map(|i| i.len() + 2).sum::<usize>())
                + (self.v.iter().map(|i| i.size()).sum::<usize>())
                + (self.g as usize * (1))
                + (self.x.iter().map(|i| i.size()).sum::<usize>())
                + self.y.len() * (1)
                + 1
                + (self.z.as_bytes().len() + 2)
        }
    }
    #[derive(Debug)]
    pub struct Wow {
        pub amazing: Vec<u8>,
    }
    impl Default for Wow {
        fn default() -> Self {
            Self { amazing: vec![] }
        }
    }
    impl Pstruct for Wow {
        fn encode(&self) -> Result<Vec<u8>> {
            let mut res = vec![0; self.size()];
            self.encode_buf(&mut res)?;
            Ok(res)
        }
        fn encode_buf(&self, buf: &mut [u8]) -> Result<()> {
            assert!(buf.len() >= self.size(), "todo improve errors");
            let mut buf = buf;
            (self.amazing.len() as u8).encode_le(&mut buf[..1])?;
            buf = &mut buf[1..];
            for idx in 0..self.amazing.len() {
                self.amazing[idx].encode_le(&mut buf[..1])?;
                buf = &mut buf[1..];
            }
            Ok(())
        }
        fn decode_new(data: &[u8]) -> Result<Self> {
            let mut res = Self::default();
            res.decode(data)?;
            Ok(res)
        }
        fn decode(&mut self, data: &[u8]) -> Result<()> {
            assert!(data.len() >= self.size(), "todo improve errors");
            let mut data = data;
            let mut tmp_len: u8 = 0;
            tmp_len.decode_le(&data[..1])?;
            data = &data[1..];
            self.amazing = Vec::with_capacity(tmp_len as usize);
            for idx in 0..(tmp_len as usize) {
                self.amazing.push(Default::default());
            }
            for idx in 0..(tmp_len as usize) {
                let size = 1;
                self.amazing[idx].decode_le(&data[..size])?;
                data = &data[size..];
            }
            Ok(())
        }
        fn size(&self) -> usize {
            self.amazing.len() * (1) + 1
        }
    }
    #[derive(Debug)]
    pub struct S {
        pub t: String,
    }
    impl Default for S {
        fn default() -> Self {
            Self {
                t: Default::default(),
            }
        }
    }
    impl Pstruct for S {
        fn encode(&self) -> Result<Vec<u8>> {
            let mut res = vec![0; self.size()];
            self.encode_buf(&mut res)?;
            Ok(res)
        }
        fn encode_buf(&self, buf: &mut [u8]) -> Result<()> {
            assert!(buf.len() >= self.size(), "todo improve errors");
            let mut buf = buf;
            (self.t.len() as u16).encode_le(&mut buf[..2])?;
            buf = &mut buf[2..];
            self.t
                .as_bytes()
                .to_vec()
                .encode_le(&mut buf[..self.t.len()])?;
            buf = &mut buf[self.t.len()..];
            Ok(())
        }
        fn decode_new(data: &[u8]) -> Result<Self> {
            let mut res = Self::default();
            res.decode(data)?;
            Ok(res)
        }
        fn decode(&mut self, data: &[u8]) -> Result<()> {
            assert!(data.len() >= self.size(), "todo improve errors");
            let mut data = data;
            let mut tmp_len: u16 = 0;
            tmp_len.decode_le(&data[..2])?;
            data = &data[2..];
            let mut tmp_buf: Vec<u8> = vec![0; tmp_len as usize];
            tmp_buf.decode_le(&data[..(tmp_len as usize)])?;
            self.t = String::from_utf8(tmp_buf).unwrap();
            data = &data[(tmp_len as usize)..];
            Ok(())
        }
        fn size(&self) -> usize {
            self.t.len() + 2
        }
    }
}
