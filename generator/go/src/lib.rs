use pstruct::types::*;

use fomat_macros::{fomat, wite};

use std::fmt;

pub static GENERATED_HEADER: &str = "// AUTOGENERATED - MAY BE OVERWRITTEN";

struct GoType<'a>(&'a Type<'a>);
struct GoEndian<'a>(&'a Endian);
struct GoStruct<'a>(&'a Struct<'a>);

impl fmt::Display for GoType<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match &self.0 {
            Type::U8 => "uint8",
            Type::U16 => "uint16",
            Type::U32 => "uint32",
            Type::U64 => "uint64",
            Type::I8 => "int8",
            Type::I16 => "int16",
            Type::I32 => "int32",
            Type::I64 => "int64",
            Type::F32 => "float32",
            Type::F64 => "float64",
            Type::Byte => "byte",
            Type::String => "string",
            Type::CString => "string",
            Type::User(user_type) => user_type,
        };
        write!(f, "{}", s)
    }
}

impl fmt::Display for GoEndian<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.0 {
            Endian::Little => {
                write!(f, "binary.LittleEndian")
            }
            Endian::Big => {
                write!(f, "binary.BigEndian")
            }
        }
    }
}

fn some_kind_of_uppercase_first_letter(s: &str) -> String {
    let mut c = s.chars(); // TODO something better than this
    match c.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
    }
}

fn alt(ty: &Type) -> String {
    some_kind_of_uppercase_first_letter(
        fomat!(match ty {
            Type::Byte => {
                [Type::U8]
            }
            _ => {
                [ty]
            }
        })
        .as_str(),
    )
}

fn type_write_border(ty: &Type, endian: Endian) -> String {
    if is_multibyte(ty) {
        fomat!(", "(GoEndian(&endian)))
    } else {
        String::new()
    }
}

fn type_read_border(ty: &Type, endian: Endian) -> String {
    if is_multibyte(ty) {
        fomat!((GoEndian(&endian)))
    } else {
        String::new()
    }
}

fn is_multibyte(ty: &Type) -> bool {
    !matches!(
        ty,
        Type::Byte | Type::U8 | Type::I8 | Type::CString | Type::User(_)
    )
}

fn item_write_border(item: &Item) -> String {
    match item.kind {
        Type::Byte | Type::U8 | Type::I8 => String::new(),
        _ => fomat!(", "(GoEndian(&item.byte_order))),
    }
}

fn item_read_border(item: &Item) -> String {
    match item.kind {
        Type::Byte | Type::U8 | Type::I8 => String::new(),
        _ => fomat!((GoEndian(&item.byte_order))),
    }
}

fn file_uses_byte_order(file: &File) -> bool {
    for s in file.structs.iter() {
        for item in s.items.iter() {
            if is_multibyte(&item.kind) {
                return true;
            }
            if let Some(arr) = &item.array {
                match arr {
                    Array::Variable(_, arr_kind) | Array::Unknown(arr_kind) => {
                        if is_multibyte(arr_kind) {
                            return true;
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    false
}

fn render_encode_item(item: &Item, var_name: &str) -> String {
    let item_kind = alt(&item.kind);
    if let Some(arr) = &item.array {
        let emit_for_loop = !matches!(item.kind, Type::CString | Type::Byte | Type::U8);
        fomat!(
            match &arr {
                Array::Unknown(arr_kind) => {
                    if item.kind == Type::CString {
                        // don't forget + 1 for null byte in unsized cstrings
                        "\t" "err = stream.Write" (alt(arr_kind)) "(" (GoType(arr_kind)) "(len(" (var_name) "." (item.name) ") + 1)" (type_write_border(arr_kind, item.byte_order)) ")" "\n"
                    } else {
                        "\t" "err = stream.Write" (alt(arr_kind)) "(" (GoType(arr_kind)) "(len(" (var_name) "." (item.name) "))" (type_write_border(arr_kind, item.byte_order)) ")" "\n"
                    }
                    "\t" "if err != nil {" "\n"
                    "\t\t" "return err" "\n"
                    "\t" "}" "\n"
                }
                _ => {}
            }
            if emit_for_loop {
                "\t" "for idx := 0; idx < int("
                    match &arr {
                        Array::Constant(size)         => { (size) }
                        Array::Unknown(_)             => { "len("(var_name)"."(item.name)")" }
                        Array::Variable(size_name, _) => { (var_name)"."(size_name) }
                    }
                    "); idx++ {" "\n"
            }
            match &item.kind {
                // these types have specialized array functions
                Type::CString => {
                    match &arr {
                        Array::Constant(size) => {
                            "\t" "err = stream.WriteCString(" (var_name) "." (item.name) ", " (size) ")" "\n"
                        }
                        Array::Variable(size_name, _) => {
                            "\t" "err = stream.WriteCString(" (var_name) "." (item.name) ", int(" (var_name) "." (size_name) "))" "\n"
                        }
                        Array::Unknown(_) => {
                            // don't forget + 1 for null byte
                            "\t" "err = stream.WriteCString(" (var_name) "." (item.name) ", int(len(" (var_name) "." (item.name) ") + 1))" "\n"
                        }
                    }
                }
                Type::Byte | Type::U8 => {
                    "\t" "err = stream.WriteBytes(" (var_name) "." (item.name) ")" "\n"
                }

                // regular arrays, inside for loop:
                Type::User(_) => {
                    "\t\t" "err = " (var_name) "." (item.name) "[idx].EncodeStream(stream)" "\n"
                }
                _ => {
                    "\t\t" "err = stream.Write" (item_kind) "(" (var_name) "." (item.name) "[idx]" (item_write_border(item)) ")" "\n"
                }
            }
            "\t\t" "if err != nil {" "\n"
            "\t\t\t" "return err" "\n"
            "\t\t" "}" "\n"
            if emit_for_loop {
                "\t" "}" "\n"
            }
        )
    } else {
        // not array
        fomat!(
            match &item.kind {
                Type::User(_) => {
                    "\t" "err = " (var_name) "." (item.name) ".EncodeStream(stream)" "\n"
                }
                Type::CString => {
                    "\t" "err = stream.WriteCStringUnsized(" (var_name) "." (item.name) ")" "\n"
                }
                _ => {
                    "\t" "err = stream.Write" (item_kind) "(" (var_name) "." (item.name) (item_write_border(item)) ")" "\n"
                }
            }
            "\t" "if err != nil {" "\n"
            "\t\t" "return err" "\n"
            "\t" "}" "\n"
        )
    }
}

fn render_decode_item(item: &Item, var_name: &str) -> String {
    let item_kind = alt(&item.kind);
    if let Some(arr) = &item.array {
        let emit_for_loop = !matches!(item.kind, Type::CString | Type::Byte | Type::U8);
        fomat!(
            match &arr {
                Array::Constant(size) => {
                    if emit_for_loop {
                        "\t" (var_name) "." (item.name) " = make([]" (GoType(&item.kind)) ", " (size) ")" "\n"
                    }
                }
                Array::Variable(size_name, _) => {
                    if emit_for_loop {
                        "\t" (var_name) "." (item.name) " = make([]" (GoType(&item.kind)) ", " (var_name) "." (size_name) ")" "\n"
                    }
                }
                Array::Unknown(arr_kind) => {
                    "\t" (var_name) (some_kind_of_uppercase_first_letter(item.name)) "Size, err := stream.Read" (alt(arr_kind)) "(" (type_read_border(arr_kind, item.byte_order)) ")" "\n"
                    "\t" "if err != nil {" "\n"
                    "\t\t" "return err" "\n"
                    "\t" "}" "\n"
                    if emit_for_loop {
                        "\t" (var_name) "." (item.name) " = make([]" (GoType(&item.kind)) ", " (var_name) (some_kind_of_uppercase_first_letter(item.name)) "Size)" "\n"
                    }
                }
            }
            if emit_for_loop {
                "\t" "for idx := 0; idx < int("
                    match &arr {
                        Array::Constant(size)        => { (size) }
                        Array::Unknown(_)            => { (var_name) (some_kind_of_uppercase_first_letter(item.name)) "Size" }
                        Array::Variable(size_name,_) => { (var_name) "." (size_name) }
                    }
                    "); idx++ {" "\n"
            }
            match &item.kind {
                // these types have specialized array functions
                Type::CString => {
                    match &arr {
                        Array::Constant(size) => {
                            "\t" (var_name) "." (item.name) ", err = stream.ReadCString(" (size) ")" "\n"
                        }
                        Array::Variable(size_name, _) => {
                            "\t" (var_name) "." (item.name) ", err = stream.ReadCString(int(" (var_name) "." (size_name) "))" "\n"
                        }
                        Array::Unknown(_) => {
                            "\t" (var_name) "." (item.name) ", err = stream.ReadCString(int(" (var_name) (some_kind_of_uppercase_first_letter(item.name)) "Size))" "\n"
                        }
                    }
                }
                Type::Byte | Type::U8 => {
                    match &arr {
                        Array::Constant(size) => {
                            "\t" (var_name) "." (item.name) ", err = stream.ReadBytes(" (size) ")" "\n"
                        }
                        Array::Variable(size_name, _) => {
                            "\t" (var_name) "." (item.name) ", err = stream.ReadBytes(int(" (var_name) "." (size_name) "))" "\n"
                        }
                        Array::Unknown(_) => {
                            "\t" (var_name) "." (item.name) ", err = stream.ReadBytes(int(" (var_name) (some_kind_of_uppercase_first_letter(item.name)) "Size))" "\n"
                        }
                    }
                }

                // regular arrays, inside for loop:
                Type::User(_) => {
                    "\t\terr = " (var_name) "." (item.name) "[idx].DecodeStream(stream)\n"
                }
                _ => {
                    "\t\t" (var_name) "." (item.name) "[idx], err = stream.Read" (item_kind) "(" (item_read_border(item)) ")\n"
                }
            }
            "\t\t" "if err != nil {" "\n"
            "\t\t\t" "return err" "\n"
            "\t\t" "}" "\n"
            if emit_for_loop {
                "\t" "}" "\n"
            }
        )
    } else {
        // not array
        fomat!(
            match &item.kind {
                Type::User(_) => {
                    "\t" "err = " (var_name) "." (item.name) ".DecodeStream(stream)" "\n"
                }
                Type::CString => {
                    "\t" (var_name) "." (item.name) ", err = stream.ReadCStringUnsized()" "\n"
                }
                _ => {
                    "\t" (var_name) "." (item.name) ", err = stream.Read" (item_kind) "(" (item_read_border(item)) ")" "\n"
                }
            }
            "\t" "if err != nil {" "\n"
            "\t\t" "return err" "\n"
            "\t" "}" "\n"
        )
    }
}

impl fmt::Display for GoStruct<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let var_name = self
            .0
            .name
            .get(0..1)
            .map(|x| x.to_lowercase())
            .ok_or(fmt::Error)?;
        wite!(
            f,
            "type " (self.0.name) " struct {" "\n"
            for item in &self.0.items {
                match &item.array {
                    Some(_) => {
                        if item.kind == Type::CString {
                            "\t" (item.name) "\t" (GoType(&item.kind)) "\n"
                        } else {
                            "\t" (item.name) "\t" "[]" (GoType(&item.kind)) "\n"
                        }
                    }
                    None => { "\t" (item.name) "\t" (GoType(&item.kind)) "\n" }
                } // TODO do something better?
            }
            "}" "\n\n"
        )?;
        wite!(
            f,
            "func New" (self.0.name) "() " (self.0.name) " {" "\n"
            "\t" "res := " (self.0.name) "{}" "\n"
            for item in &self.0.items {
                if item.kind != Type::CString {
                    match &item.array {
                        Some(Array::Constant(size)) => {
                            "\t" "res." (item.name) " = make([]" (GoType(&item.kind)) ", " (size) ")" "\n"
                        }
                        _ => {}
                    }
                }
            }
            "\t" "return res" "\n"
            "}" "\n\n"
        )?;
        wite!(
            f,
            "func (" (var_name) " *" (self.0.name) ") Encode() ([]byte, error) {" "\n"
            "\t" "var buf bytes.Buffer" "\n"
            "\t" "stream := ps.NewStreamWithWriter(&buf)" "\n"
            "\t" "err := "(var_name) ".EncodeStream(stream)" "\n"
            "\t" "if err != nil {" "\n"
            "\t\t" "return nil, err" "\n"
            "\t" "}" "\n"
            "\t" "return buf.Bytes(), nil" "\n"
            "}" "\n\n"
            "func (" (var_name) " *" (self.0.name) ") Decode(data []byte) error {" "\n"
            "\t" "return " (var_name) ".DecodeStream(ps.NewStreamWithSlice(data))" "\n"
            "}" "\n\n"
        )?;
        wite!(
            f,
            "func (" (var_name) " *" (self.0.name) ") EncodeStream(stream *ps.Stream) error {" "\n"
            "\t" "var err error" "\n"
            for item in &self.0.items {
                (render_encode_item(item, var_name.as_str()))
            }
            "\t" "return nil" "\n"
            "}" "\n\n"
            "func (" (var_name) " *" (self.0.name) ") DecodeStream(stream *ps.Stream) error {" "\n"
            "\t" "var err error" "\n"
            for item in &self.0.items {
                (render_decode_item(item, var_name.as_str()))
            }
            "\t" "return nil" "\n"
            "}" "\n\n"
        )
    }
}

pub fn render_file(file: &File) -> String {
    fomat!(
        (GENERATED_HEADER) "\n\n"
        "package " (file.scope.to_lowercase()) "\n\n"
        for raw_import in &file.raw_imports {
            "import \"" (raw_import) "\"\n"
        }
        r#"import "bytes""# "\n"
        if file_uses_byte_order(file) {
            r#"import "encoding/binary""# "\n"
        }
        r#"import ps "github.com/wwared/pstruct/runtime/go""# "\n\n"
        for definition in &file.structs {
            (GoStruct(definition))
        }
    )
}
