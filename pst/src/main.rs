use io::Write;
use std::path::PathBuf;
use std::{error, fmt, fs, io, process};

use pstruct::parser;

use gumdrop::Options;
use walkdir::WalkDir;

struct Error(Box<dyn error::Error>);

impl<E: Into<Box<dyn error::Error>>> From<E> for Error {
    fn from(e: E) -> Self {
        Error(e.into())
    }
}

impl fmt::Debug for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)?;
        let mut source = self.0.source();
        while let Some(error) = source {
            write!(f, "\ncaused by: {}", error)?;
            source = error.source();
        }
        Ok(())
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)?;
        let mut source = self.0.source();
        while let Some(error) = source {
            write!(f, "\ncaused by: {}", error)?;
            source = error.source();
        }
        Ok(())
    }
}

#[derive(Options)]
struct CliOptions {
    #[options(free, help = "output language", parse(try_from_str = "parse_lang"))]
    language: Option<Language>,

    #[options(
        free,
        help = "input files or directories",
        parse(from_str = "parse_path")
    )]
    spec_files: Vec<PathBuf>,

    #[options(help = "print this help message")]
    help: bool,

    #[options(help = "output directory", parse(from_str = "parse_path"))]
    output: Option<PathBuf>,

    #[options(help = "print to stdout; useful for debugging")]
    print_output: bool,

    #[options(help = "don't write any files")]
    dry_run: bool,

    #[options(no_short, help = "don't autoformat on generated files")]
    disable_auto_format: bool,
}

#[derive(Clone, Copy)]
enum Language {
    Go,
    Rust,
}

fn parse_lang(s: &str) -> Result<Language, Error> {
    match s.to_lowercase().as_str() {
        "go" => Ok(Language::Go),
        "rust" => Ok(Language::Rust),
        _ => Err("invalid language; valid values: go, rust".into()),
    }
}

fn parse_path(s: &str) -> PathBuf {
    PathBuf::from(s)
}

fn print_usage_and_error(error: Option<&str>) -> ! {
    if let Some(s) = error {
        println!("ERROR: {}\n", s);
    }
    println!("{}", CliOptions::usage());
    process::exit(error.is_none() as i32);
}

fn main() -> Result<(), Error> {
    let opts = CliOptions::parse_args_default_or_exit();

    if opts.help_requested() {
        print_usage_and_error(None);
    }

    if opts.language.is_none() {
        print_usage_and_error(Some("no language specified; valid values: go, rust"));
    }

    // get input files
    let mut files = vec![];
    for path in &opts.spec_files {
        if path.is_dir() {
            for entry in WalkDir::new(path).follow_links(true) {
                let subpath = entry?.into_path();
                if !subpath.is_file() {
                    continue;
                }
                if let Some(ext) = subpath.extension() {
                    if ext.to_string_lossy().to_lowercase() == "zs" {
                        files.push(subpath);
                    }
                }
            }
        } else if path.is_file() {
            files.push(path.clone());
        } else {
            eprintln!("'{}' does not exist, ignoring...", path.to_string_lossy());
        }
    }
    if files.is_empty() {
        print_usage_and_error(Some("no files specified"));
    }

    // validate output directory
    if let Some(dir) = &opts.output {
        if !dir.exists() || dir.is_file() {
            print_usage_and_error(Some(
                format!("'{}' is not a directory", dir.to_string_lossy()).as_str(),
            ));
        }
    }

    // render files
    match opts.language.unwrap() {
        Language::Go => render_go_files(&opts, &files)?,
        Language::Rust => render_rust_files(&opts, &files)?,
    }

    println!("done!");
    Ok(())
}

fn render_go_files(opts: &CliOptions, files: &[PathBuf]) -> Result<(), Error> {
    let mut rendered_files = vec![];

    for file in files {
        let mut output = match &opts.output {
            Some(dir) => {
                let mut p = dir.clone();
                p.push(file.file_name().unwrap());
                p
            }
            None => file.clone(),
        };
        output.set_extension("go");

        if output.exists() {
            let file = fs::read_to_string(&output)?;
            if !file.starts_with(pstruct_go::GENERATED_HEADER) {
                return Err(Error::from(io::Error::new(
                    io::ErrorKind::Other,
                    format!(
                        "{} does not seem to be autogenerated -- aborting",
                        output.to_string_lossy()
                    ),
                )));
            }
        }

        println!("{} -> {}", file.to_str().unwrap(), output.to_string_lossy());
        let file_contents = fs::read_to_string(file)?;
        let file = parser::parse_file(file_contents.as_str())?;
        let rendered_file = pstruct_go::render_file(&file);
        if opts.print_output {
            println!("{}", rendered_file);
        }
        rendered_files.push((output, rendered_file));
        println!();
    }

    if opts.dry_run {
        println!("dry run -- will not write files");
        return Ok(());
    }

    for (output, rendered_file) in &rendered_files {
        fs::write(output, rendered_file)?;
    }

    if !opts.disable_auto_format {
        println!("running go fmt...");
        process::Command::new("go")
            .arg("fmt")
            .args(rendered_files.iter().map(|(f, _)| f))
            .status()?;
    }

    Ok(())
}

fn render_rust_files(opts: &CliOptions, files: &[PathBuf]) -> Result<(), Error> {
    let mut rendered_files = vec![];

    for file in files {
        let mut output = match &opts.output {
            Some(dir) => {
                let mut p = dir.clone();
                p.push(file.file_name().unwrap());
                p
            }
            None => file.clone(),
        };
        output.set_extension("rs");

        if output.exists() {
            let file = fs::read_to_string(&output)?;
            if !file.starts_with(pstruct_rust::GENERATED_HEADER) {
                return Err(Error::from(io::Error::new(
                    io::ErrorKind::Other,
                    format!(
                        "{} does not seem to be autogenerated -- aborting",
                        output.to_string_lossy()
                    ),
                )));
            }
        }

        println!("{} -> {}", file.to_str().unwrap(), output.to_string_lossy());
        let file_contents = fs::read_to_string(file)?;
        let file = parser::parse_file(file_contents.as_str())?;
        let mut rendered_file = pstruct_rust::render_file(&file);

        if !opts.disable_auto_format {
            let mut child = process::Command::new("rustfmt")
                .stdin(process::Stdio::piped())
                .stdout(process::Stdio::piped())
                .stderr(process::Stdio::piped())
                .spawn()?;

            let mut stdin = child.stdin.take().unwrap();
            write!(stdin, "{rendered_file}")?;
            stdin.flush()?;
            drop(stdin);

            let process::Output {
                status,
                stdout,
                stderr,
            } = child.wait_with_output()?;
            let stdout = String::from_utf8_lossy(&stdout);
            let stderr = String::from_utf8_lossy(&stderr);

            if !status.success() {
                eprintln!("---- Stdout ----");
                eprintln!("{stdout}");
                eprintln!("---- Stderr ----");
                eprintln!("{stderr}");
                let code = status.code();
                match code {
                    Some(code) => {
                        return Err(
                            format!("The `rustfmt` command failed with return code {code}").into(),
                        )
                    }
                    None => return Err("The `rustfmt` command failed".into()),
                }
            }

            rendered_file = stdout.into();
        }

        if opts.print_output {
            println!("{}", rendered_file);
        }

        rendered_files.push((output, rendered_file));
        println!();
    }

    if opts.dry_run {
        println!("dry run -- will not write files");
        return Ok(());
    }

    for (output, rendered_file) in &rendered_files {
        fs::write(output, rendered_file)?;
    }

    Ok(())
}
