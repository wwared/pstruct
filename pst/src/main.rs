use std::path::PathBuf;
use std::{error, fmt, fs, io, process};

use pstruct::parser;

use pstruct_go;

use gumdrop::Options;
use walkdir::WalkDir;

struct Error(Box<dyn error::Error>);

impl<E: Into<Box<dyn error::Error>>> From<E> for Error {
    fn from(e: E) -> Self {
        Error(e.into())
    }
}

impl fmt::Debug for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)?;
        let mut source = self.0.source();
        while let Some(error) = source {
            write!(f, "\ncaused by: {}", error)?;
            source = error.source();
        }
        Ok(())
    }
}


#[derive(Options)]
struct CliOptions {
    #[options(free, help = "input files or directories", parse(from_str = "parse_path"))]
    spec_files: Vec<PathBuf>,

    #[options(help = "print this help message")]
    help: bool,

    #[options(help = "output directory", parse(from_str = "parse_path"))]
    output: Option<PathBuf>,

    #[options(help = "print to stdout; useful for debugging")]
    print_output: bool,

    #[options(help = "don't write any files")]
    dry_run: bool,

    #[options(no_short, help = "don't run go fmt on generated files")]
    disable_auto_format: bool,
}

fn parse_path(s: &str) -> PathBuf {
    PathBuf::from(s)
}

fn print_usage_and_error(error: Option<&str>) -> ! {
    if let Some(s) = error {
        println!("ERROR: {}\n", s);
    }
    println!("{}", CliOptions::usage());
    process::exit(error.is_none() as i32);
}

fn main() -> Result<(), Error> {
    let opts = CliOptions::parse_args_default_or_exit();

    if opts.help_requested() {
        print_usage_and_error(None);
    }

    // get input files
    let mut files = vec![];
    for path in &opts.spec_files {
        if path.is_dir() {
            for entry in WalkDir::new(path).follow_links(true) {
                let subpath = entry?.into_path();
                if !subpath.is_file() {
                    continue;
                }
                if let Some(ext) = subpath.extension() {
                    if ext.to_string_lossy().to_lowercase() == "zs" {
                        files.push(subpath);
                    }
                }
            }
        } else if path.is_file() {
            files.push(path.clone());
        } else {
            eprintln!("'{}' does not exist, ignoring...", path.to_string_lossy());
        }
    }
    if files.is_empty() {
        print_usage_and_error(Some("no files specified"));
    }

    // validate output directory
    if let Some(dir) = &opts.output {
        if  !dir.exists() || dir.is_file() {
            print_usage_and_error(Some(format!("'{}' is not a directory", dir.to_string_lossy()).as_str()));
        }
    }

    // render files
    let mut rendered_files = vec![];
    for file in &files {
        let mut output = match &opts.output {
            Some(dir) => {
                let mut p = dir.clone();
                p.push(file.file_name().unwrap());
                p
            },
            None => file.clone(),
        };
        output.set_extension("go");

        if output.exists() {
            let file = fs::read_to_string(&output)?;
            if !file.starts_with(pstruct_go::GENERATED_HEADER) {
                return Err(Error::from(io::Error::new(io::ErrorKind::Other, format!("{} does not seem to be autogenerated -- aborting", output.to_string_lossy()))));
            }
        }

        println!("{} -> {}", file.to_str().unwrap(), output.to_string_lossy());
        let file_contents = fs::read_to_string(file)?;
        let file = parser::parse_file(file_contents.as_str())?;
        let rendered_file = pstruct_go::render_file(&file);
        if opts.print_output {
            println!("{}", rendered_file);
        }
        rendered_files.push((output, rendered_file));
        println!();
    }

    if opts.dry_run {
        println!("dry run -- will not write files");
        return Ok(());
    }

    for (output, rendered_file) in &rendered_files {
        fs::write(output, rendered_file)?;
    }
    if !opts.disable_auto_format {
        println!("running go fmt...");
        process::Command::new("go")
            .arg("fmt")
            .args(rendered_files.iter().map(|(f, _)| f))
            .status()?;
    }

    println!("done!");
    Ok(())
}
