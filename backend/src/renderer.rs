use crate::types::*;

use fomat_macros::{fomat, wite};

use std::fmt;

pub static GENERATED_HEADER: &str = "// AUTOGENERATED - MAY BE OVERWRITTEN";

impl fmt::Display for Type<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        wite!(
            f,
            match &self {
                Type::U8              => { "uint8" }
                Type::U16             => { "uint16" }
                Type::U32             => { "uint32" }
                Type::U64             => { "uint64" }
                Type::I8              => { "int8" }
                Type::I16             => { "int16" }
                Type::I32             => { "int32" }
                Type::I64             => { "int64" }
                Type::F32             => { "float32" }
                Type::F64             => { "float64" }
                Type::Byte            => { "byte" }
                Type::String          => { "string" }
                Type::CString         => { "string" }
                Type::User(user_type) => { (user_type) }
            }
        )
    }
}

impl fmt::Display for Array<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "[]")
    }
}

impl fmt::Display for Endian {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self {
            Endian::Little => { write!(f, "binary.LittleEndian") },
            Endian::Big    => { write!(f, "binary.BigEndian") },
        }
    }
}

fn some_kind_of_uppercase_first_letter(s: &str) -> String {
    let mut c = s.chars(); // TODO something better than this
    match c.next() {
        None    => String::new(),
        Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
    }
}

impl Type<'_> {
    fn alt(&self) -> String {
        some_kind_of_uppercase_first_letter(
            fomat!(match &self {
                Type::Byte => { [Type::U8] }
                _          => { [self] }
            }).as_str(),
        )
    }

    fn write_border(&self, endian: Endian) -> String {
        match &self {
            Type::Byte | Type::U8 | Type::I8 => String::new(),
            _ => fomat!(", " (endian)),
        }
    }

    fn read_border(&self, endian: Endian) -> String {
        match &self {
            Type::Byte | Type::U8 | Type::I8 => String::new(),
            _ => fomat!((endian)),
        }
    }

    fn is_byte_for_arr(&self) -> bool {
        matches!(&self, Type::Byte | Type::U8)
    }
}

impl Item<'_> {
    fn write_border(&self) -> String {
        match &self.kind {
            Type::Byte | Type::U8 | Type::I8 => String::new(),
            _ => fomat!(", " (self.byte_order)),
        }
    }

    fn read_border(&self) -> String {
        match &self.kind {
            Type::Byte | Type::U8 | Type::I8 => String::new(),
            _ => fomat!((self.byte_order)),
        }
    }
}

fn render_encode_item(item: &Item, var_name: &str) -> String {
    let item_kind = &item.kind.alt();
    let regular_arr = item.kind != Type::CString && !item.kind.is_byte_for_arr();
    if let Some(arr) = &item.array {
        fomat!(
            if regular_arr {
                match &arr {
                    Array::Unknown(arr_kind) => {
                        "\t" "stream.Write" (arr_kind.alt()) "(" (arr_kind) "(len(" (var_name) "." (item.name) "))" (arr_kind.write_border(item.byte_order)) ")" "\n"
                    }
                    _ => {}
                }
                "\t" "for idx := 0; idx < int("
                    match &arr {
                        Array::Constant(size)         => { (size) }
                        Array::Unknown(_)             => { "len("(var_name)"."(item.name)")" }
                        Array::Variable(size_name, _) => { (var_name)"."(size_name) }
                    }
                    "); idx++ {" "\n"
            }
            match &item.kind {
                Type::CString => {
                    match &arr {
                        Array::Constant(size) => {
                            "\t" "stream.WriteCString(" (var_name) "." (item.name) ", " (size) ")" "\n"
                        }
                        Array::Variable(size_name, _) => {
                            "\t" "stream.WriteCString(" (var_name) "." (item.name) ", uint64(" (var_name) "." (size_name) "))" "\n"
                        }
                        Array::Unknown(arr_kind) => {
                            // don't forget + 1 for null byte
                            "\t" "stream.Write" (arr_kind.alt()) "(" (arr_kind) "(len(" (var_name) "." (item.name) ") + 1)" (arr_kind.write_border(item.byte_order)) ")" "\n"
                            "\t" "stream.WriteCString(" (var_name) "." (item.name) ", uint64(len(" (var_name) "." (item.name) ") + 1))" "\n"
                        }
                    }
                }
                Type::Byte | Type::U8 => {
                    "\t" "stream.WriteBytes(" (var_name) "." (item.name) ")" "\n"
                }
                // regular arrays:
                Type::User(_) => {
                    "\t\t" (var_name) "." (item.name) "[idx].EncodeStream(stream)" "\n"
                }
                _ => {
                    "\t\t" "stream.Write" (item_kind) "(" (var_name) "." (item.name) "[idx]" (item.write_border()) ")" "\n"
                }
            }
            if regular_arr {
                "\t" "}" "\n"
            }
        )
    } else { // not array
        fomat!(
            match &item.kind {
                Type::User(_) => {
                    "\t" (var_name) "." (item.name) ".EncodeStream(stream)" "\n"
                }
                Type::CString => {
                    "\t" "stream.WriteCStringUnsized(" (var_name) "." (item.name) ")" "\n"
                }
                _ => {
                    "\t" "stream.Write" (item_kind) "(" (var_name) "." (item.name) (item.write_border()) ")" "\n"
                }
            }
        )
    }
}

fn render_decode_item(item: &Item, var_name: &str) -> String {
    let item_kind = &item.kind.alt();
    let regular_arr = item.kind != Type::CString && !item.kind.is_byte_for_arr();
    if let Some(arr) = &item.array {
        fomat!(
            if regular_arr {
                match &arr {
                    Array::Constant(size) => {
                        "\t" (var_name) "." (item.name) " = make([]" (item.kind) ", " (size) ")" "\n"
                    }
                    Array::Variable(size_name, _) => {
                        "\t" (var_name) "." (item.name) " = make([]" (item.kind) ", " (var_name) "." (size_name) ")" "\n"
                    }
                    Array::Unknown(arr_kind) => {
                        "\t" (var_name) (some_kind_of_uppercase_first_letter(item.name)) "Size, err := stream.Read" (arr_kind.alt()) "(" (arr_kind.read_border(item.byte_order)) ")" "\n"
                        "\t" "if err != nil {" "\n"
                        "\t\t" "return err" "\n"
                        "\t" "}" "\n"
                        "\t" (var_name) "." (item.name) " = make([]" (item.kind) ", " (var_name) (some_kind_of_uppercase_first_letter(item.name)) "Size)" "\n"
                    }
                }
                "\t" "for idx := 0; idx < int("
                    match &arr {
                        Array::Constant(size)        => { (size) }
                        Array::Unknown(_)            => { (var_name) (some_kind_of_uppercase_first_letter(item.name)) "Size" }
                        Array::Variable(size_name,_) => { (var_name) "." (size_name) }
                    }
                    "); idx++ {" "\n"
            }
            match &item.kind {
                Type::CString => {
                    match &arr {
                        Array::Constant(size) => {
                            "\t" (var_name) "." (item.name) ", err = stream.ReadCString(" (size) ")" "\n"
                        }
                        Array::Variable(size_name, _) => {
                            "\t" (var_name) "." (item.name) ", err = stream.ReadCString(uint64(" (var_name) "." (size_name) "))" "\n"
                        }
                        Array::Unknown(arr_kind) => {
                            "\t" (var_name) (some_kind_of_uppercase_first_letter(item.name)) "Size, err := stream.Read" (arr_kind.alt()) "(" (arr_kind.read_border(item.byte_order)) ")" "\n"
                            "\t" "if err != nil {" "\n"
                            "\t\t" "return err" "\n"
                            "\t" "}" "\n"
                            "\t" (var_name) "." (item.name) ", err = stream.ReadCString(uint64(" (var_name) (some_kind_of_uppercase_first_letter(item.name)) "Size))" "\n"
                        }
                    }
                }
                Type::Byte | Type::U8 => {
                    match &arr {
                        Array::Constant(size) => {
                            "\t" (var_name) "." (item.name) ", err = stream.ReadBytes(" (size) ")" "\n"
                        }
                        Array::Variable(size_name, _) => {
                            "\t" (var_name) "." (item.name) ", err = stream.ReadBytes(uint64(" (var_name) "." (size_name) "))" "\n"
                        }
                        Array::Unknown(arr_kind) => {
                            "\t" (var_name) (some_kind_of_uppercase_first_letter(item.name)) "Size, err := stream.Read" (arr_kind.alt()) "(" (arr_kind.read_border(item.byte_order)) ")" "\n"
                            "\t" "if err != nil {" "\n"
                            "\t\t" "return err" "\n"
                            "\t" "}" "\n"
                            "\t" (var_name) "." (item.name) ", err = stream.ReadBytes(uint64(" (var_name) (some_kind_of_uppercase_first_letter(item.name)) "Size))" "\n"
                        }
                    }
                }
                // regular arrays:
                Type::User(_) => {
                    "\t\terr = " (var_name) "." (item.name) "[idx].DecodeStream(stream)\n"
                }
                _ => {
                    "\t\t" (var_name) "." (item.name) "[idx], err = stream.Read" (item_kind) "(" (item.read_border()) ")\n"
                }
            }
            "\t\t" "if err != nil {" "\n"
            "\t\t\t" "return err" "\n"
            "\t\t" "}" "\n"
            if regular_arr {
                "\t" "}" "\n"
            }
        )
    } else { // not array
        fomat!(
            match &item.kind {
                Type::User(_) => {
                    "\t" "err = " (var_name) "." (item.name) ".DecodeStream(stream)" "\n"
                }
                Type::CString => {
                    "\t" (var_name) "." (item.name) ", err = stream.ReadCStringUnsized()" "\n"
                }
                _ => {
                    "\t" (var_name) "." (item.name) ", err = stream.Read" (item_kind) "(" (item.read_border()) ")" "\n"
                }
            }
            "\t" "if err != nil {" "\n"
            "\t\t" "return err" "\n"
            "\t" "}" "\n"
        )
    }
}

impl fmt::Display for Struct<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let var_name = self.name.get(0..1) .map(|x| x.to_lowercase()) .ok_or(fmt::Error)?;
        wite!(
            f,
            "type " (self.name) " struct {" "\n"
            for item in &self.items {
                match &item.array {
                    Some(arr) => {
                        if item.kind == Type::CString {
                            "\t" (item.name) "\t" (item.kind) "\n"
                        } else {
                            "\t" (item.name) "\t" (arr) (item.kind) "\n"
                        }
                    }
                    None => { "\t" (item.name) "\t" (item.kind) "\n" }
                } // TODO do something better?
            }
            "}" "\n\n"
            "func New" (self.name) "() " (self.name) " {" "\n"
            "\t" "res := " (self.name) "{}" "\n"
            for item in &self.items {
                if item.kind != Type::CString {
                    match &item.array {
                        Some(Array::Constant(size)) => {
                            "\t" "res." (item.name) " = make([]" (item.kind) ", " (size) ")" "\n"
                        }
                        _ => {}
                    }
                }
            }
            "\t" "return res" "\n"
            "}" "\n\n"
            "func (" (var_name) " *" (self.name) ") Encode() []byte {" "\n"
            "\t" "stream := ps.NewStream()" "\n"
            "\t" (var_name) ".EncodeStream(stream)" "\n"
            "\t" "return stream.GetData()" "\n"
            "}" "\n\n"
            "func (" (var_name) " *" (self.name) ") Decode(data []byte) error {" "\n"
            "\t" "return " (var_name) ".DecodeStream(ps.NewStreamReader(data))" "\n"
            "}" "\n\n"
            "func (" (var_name) " *" (self.name) ") EncodeStream(stream *ps.Stream) {" "\n"
            for item in &self.items {
                (render_encode_item(item, var_name.as_str()))
            }
            "}" "\n\n"
            "func (" (var_name) " *" (self.name) ") DecodeStream(stream *ps.Stream) error {" "\n"
            "\t" "var err error" "\n"
            for item in &self.items {
                (render_decode_item(item, var_name.as_str()))
            }
            "\t" "return nil" "\n"
            "}" "\n\n"
        )
    }
}

pub fn render_file(file: &File) -> String {
    fomat!(
        (GENERATED_HEADER) "\n\n"
        "package " (file.scope.to_lowercase()) "\n\n"
        r#"import "encoding/binary""# "\n"
        r#"import ps "github.com/wwared/pstruct/runtime/go""# "\n\n"
        for definition in &file.structs {
            (definition)
        }
    )
}
