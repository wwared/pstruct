#[macro_use]
extern crate pest_derive;

mod parser;
mod renderer;
mod types;

use std::{env, error, fs, path, io};

fn print_help() {
    println!("ok");
}

fn main() -> Result<(), Box<dyn error::Error>> {
    let mut files = vec![];
    let mut output_directory = None;
    let mut dry_run = false;
    for arg in env::args().skip(1) {
        if arg.starts_with('-') {
            let x: Vec<&str> = arg.trim_start_matches('-').splitn(2, '=').collect();
            match x[0].to_lowercase().as_str() {
                "h" | "help" => {
                    print_help();
                    return Ok(());
                },
                "o" | "output" => {
                    output_directory = Some(path::PathBuf::from(x[1]));
                },
                "d" | "dry" => {
                    dry_run = true;
                },
                unknown_option => {
                    eprintln!("unknown option {}", unknown_option);
                    continue;
                }
            }
        } else {
            let file = path::PathBuf::from(arg.clone());
            if file.is_dir() {
                for entry in walkdir::WalkDir::new(file).follow_links(true) {
                    let subfile = entry?.into_path();
                    if !subfile.is_file() {
                        continue;
                    }
                    if let Some(ext) = subfile.extension() {
                        if ext.to_str().unwrap().to_lowercase() == "zs" {
                            files.push(subfile);
                        }
                    }
                }
            } else if file.is_file() {
                files.push(file);
            } else {
                eprintln!("'{}' does not exist, ignoring...", arg);
            }
        }
    }
    if files.is_empty() {
        print_help();
        return Err(Box::new(io::Error::new(io::ErrorKind::Other, "no files specified")));
    }
    if let Some(dir) = &output_directory {
        if  !dir.exists() || dir.is_file() {
            return Err(Box::new(io::Error::new(io::ErrorKind::Other, format!("'{}' is not a directory", dir.to_str().unwrap()))));
        }
    }
    let mut rendered_files = vec![];
    for file in &files {
        let mut output = match &output_directory {
            Some(dir) => {
                let mut p = dir.clone();
                p.push(file.file_name().unwrap());
                p
            },
            None => file.clone(),
        };
        output.set_extension("go");

        if output.exists() {
            let file = fs::read_to_string(&output)?;
            if !file.starts_with(renderer::GENERATED_HEADER) {
                return Err(Box::new(io::Error::new(io::ErrorKind::Other, format!("{} does not seem to be autogenerated -- aborting", output.to_str().unwrap()))));
            }
        }

        println!("\n{} -> {}", file.to_str().unwrap(), output.to_str().unwrap());
        let file_contents = fs::read_to_string(file)?;
        let file = parser::parse_file(file_contents.as_str())?;
        rendered_files.push((output, renderer::render_file(&file)));
    }

    if !dry_run {
        for (output, rendered_file) in rendered_files {
            fs::write(output, rendered_file)?;
        }
    }

    Ok(())
}
