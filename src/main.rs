#[macro_use]
extern crate pest_derive;

mod parser;
mod renderer;
mod types;

use std::{error, fs, path, io};
use gumdrop::Options;

#[derive(Options)]
struct CliOptions {
    #[options(free, help = "input files or directories", parse(from_str = "parse_path"))]
    spec_files: Vec<path::PathBuf>,

    #[options(help = "print this help message")]
    help: bool,

    #[options(help = "don't write any files")]
    dry_run: bool,

    #[options(help = "output directory", parse(from_str = "parse_path"))]
    output: Option<path::PathBuf>,
}

fn parse_path(s: &str) -> path::PathBuf {
    path::PathBuf::from(s)
}

fn print_usage_and_error(error: Option<&str>) -> ! {
    if let Some(s) = error {
        println!("ERROR: {}\n", s);
    }
    println!("{}", CliOptions::usage());
    if error.is_none() {
        std::process::exit(0);
    } else {
        std::process::exit(1);
    }
}

fn main() -> Result<(), Box<dyn error::Error>> {
    let opts = CliOptions::parse_args_default_or_exit();

    if opts.help_requested() {
        print_usage_and_error(None);
    }

    // get input files
    let mut files = vec![];
    for path in &opts.spec_files {
        if path.is_dir() {
            for entry in walkdir::WalkDir::new(path).follow_links(true) {
                let subpath = entry?.into_path();
                if !subpath.is_file() {
                    continue;
                }
                if let Some(ext) = subpath.extension() {
                    if ext.to_str().unwrap().to_lowercase() == "zs" {
                        files.push(subpath);
                    }
                }
            }
        } else if path.is_file() {
            files.push(path.clone());
        } else {
            eprintln!("'{}' does not exist, ignoring...", path.to_str().unwrap());
        }
    }
    if files.is_empty() {
        print_usage_and_error(Some("no files specified"));
    }

    // validate output directory
    if let Some(dir) = &opts.output {
        if  !dir.exists() || dir.is_file() {
            print_usage_and_error(Some(format!("'{}' is not a directory", dir.to_str().unwrap()).as_str()));
        }
    }

    if opts.dry_run {
        println!("dry run -- will not write files\n");
    }

    // render files
    let mut rendered_files = vec![];
    for file in &files {
        let mut output = match &opts.output {
            Some(dir) => {
                let mut p = dir.clone();
                p.push(file.file_name().unwrap());
                p
            },
            None => file.clone(),
        };
        output.set_extension("go");

        if output.exists() {
            let file = fs::read_to_string(&output)?;
            if !file.starts_with(renderer::GENERATED_HEADER) {
                return Err(Box::new(io::Error::new(io::ErrorKind::Other, format!("{} does not seem to be autogenerated -- aborting", output.to_str().unwrap()))));
            }
        }

        println!("{} -> {}", file.to_str().unwrap(), output.to_str().unwrap());
        let file_contents = fs::read_to_string(file)?;
        let file = parser::parse_file(file_contents.as_str())?;
        rendered_files.push((output, renderer::render_file(&file)));
        println!();
    }

    if !opts.dry_run {
        for (output, rendered_file) in rendered_files {
            fs::write(output, rendered_file)?;
        }
    }

    println!("done!");
    Ok(())
}
